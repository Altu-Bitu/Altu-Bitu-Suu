//샘플 코드 + 주석 제출 (선택 문제)
#include <iostream>
#include <queue>

using namespace std;
const int SIZE = 100000;

/**
 * [최단 경로]
 * 13549 숨바꼭질 3
 * 1. 수빈이가 동생이 있는 위치에 도달할 때까지 탐색을 진행한다. 현재 위치를 덱에 넣고 탐색을 시작한다.
 * 2. 덱에서 위치 하나를 현재 위치로 꺼낸다.
 * 3. 덱에 순간이동 후 위치, 앞 뒤로 걸었을 때 위치를 넣는다. 단, 범위 안에 있어야 하며 안가본 위치(시간이 갱신되지 않은 위치)여야한다.
 * 4. 순간이동 한 위치를 먼저 탐색할 수 있도록 순간이동 후 위치를 덱 앞에 넣고, 걸었을 대의 위치를 뒤에 넣는다.
 */

int zeroOneBfs(int n, int k) { // n: 수빈이가 있는 위치, k: 동생이 있는 위치
    vector<int> check(SIZE + 1, 0); //정점에 도착한 시간. (점 N의 최댓값 = 시간 최댓값이니까 크기 SIZE + 1)
    deque<int> dq;
    int ans = 0;

    //시작 위치 초기화
    check[n] = 1; // 시작 위치를 1초로
    dq.push_back(n); // 덱에 시작 위치 넣음

    while (!dq.empty()) {
        int x = dq.front(); //현재 탐색하려는 위치
        dq.pop_front();

        if (x == k) { //동생 찾으면 탐색 종료. 시작 위치를 1로 초기화 했기 때문에 1을 빼줌
            ans = check[x] - 1;
            break;
        }

        int next = x * 2; //순간이동
        if (next <= SIZE && !check[next]) { //순간이동 하려는 위치가 범위 안이고, 아직 안가본 위치라면
            check[next] = check[x]; // 순간이동은 0초 걸리므로 현재 위치의 시간과 동일
            dq.push_front(next); // 순간이동한 위치를 덱 앞에 추가 (먼저 순간이동한 위치를 탐색하도록)
        }

        next = x - 1; //뒤로 걷기
        if (next >= 0 && !check[next]) { // 이동하려는 위치가 범위 안이고, 아직 안가본 위치라면
            check[next] = check[x] + 1; // 1초 지남
            dq.push_back(next); // 걸어서 도착한 위치는 덱 뒤에 추가. (순간이동 위치보다 나중에 탐색)
        }

        next = x + 1; //앞으로 걷기
        if (next <= SIZE && !check[next]) { // 이동하려는 위치가 범위 안이고, 아직 안가본 위치라면
            check[next] = check[x] + 1; // 1초 지남
            dq.push_back(next); // 걸어서 도착한 위치는 덱 뒤에 추가. (순간이동 위치보다 나중에 탐색)
        }
    }
    return ans; //수빈이가 동생을 찾는 가장 빠른 시간
}

/**
 * x좌표 위에서 2*x, x-1, x+1의 위치로 계속 이동하며 탐색
 * 이동에 대한 가중치는 0, 1 두 가지이므로 다익스트라가 아니라 덱으로 풀 수 있음 (0-1 BFS)
 *
 * !주의!
 * 순간이동으로 이동하는 경우를 걸어서 이동하는 경우보다 먼저 고려해야 함
 * -> 어차피 순간이동은 push_front 되는데 왜?
 * -> 1에서 2로 이동할 땐 걷는 것도 가능하고 순간이동도 가능함
 *    걷는 방법을 먼저 고려하면 check 배열이 갱신되어 순간이동을 고려할 수 없음
 */
int main() {
    int n, k;

    //입력
    cin >> n >> k;

    //연산 & 출력
    cout << zeroOneBfs(n, k) << '\n';
}